\section{Telemetry Module}

The telemetry module implements the design specified in Sec.\ \ref{sec:Telemetry-Module-Design}. The hardware and software aspects of this module's implementation are discussed in this section. Figure \ref{fig:telemetry_pcb} shows a photo of the completely populated and debugged telemetry module hardware.

\begin{figure}[H]
\centering
\includegraphics[scale=1]{implementation/figures/telemetry_pcb.eps}
\caption{Populated telemetry module PCB.}\label{fig:telemetry_pcb}
\end{figure}

\subsection{Hardware}

In addition to the base system hardware common to all modules described in Sec.\ \ref{sec:base_system_hardware}, several additional components were required in the implementation of the telemetry module. A block diagram of the telemetry module hardware implementation is shown in Fig.\ \ref{fig:telemetry_hardware_block}. The additional components are an XBee-PRO wireless mode, MAX232 RS-232 transceiver, MAX3100 external UART, an LTI1521 \unit{3.3}{\volt} linear voltage regulator, and an ST2378E 8-bit level translator. These additional components are listed in Table \ref{tab:telemetry_module_components} and will be described further in this chapter.

\begin{figure}[H]
\centering
\input{implementation/figures/telemetry_hardware_block}
\caption{Telemetry module hardware block diagram.\label{fig:telemetry_hardware_block}}
\end{figure}

\begin{table}[H]
  \caption{Telemetry module components\label{tab:telmetry_module_components}}
  \centering
    \begin{tabular}{|c|c|c|}
      \hline 
      Part & Manufacturer & Part Number\tabularnewline
      \hline
      \hline
      XBee-PRO OEM Module & Digi International & XBee-PRO\tabularnewline
      \hline 
      Dual RS-232 Transceiver & Maxim Electronics & MAX232\tabularnewline
      \hline 
      SPI-capable UART chip & Maxim Electronics & MAX3100\tabularnewline
      \hline 
      300mA Low Dropout Regulator & Linear Technology & LT1521\tabularnewline
      \hline
      8-bit dual-supply level translator & ST Microelectronics & ST2378E\tabularnewline
      \hline
    \end{tabular}
\end{table}

\subsubsection{Dual RS-232 Transceiver}

The ECU and the DAQ modules connect to the telemetry board with specialized cables that connect to the wiring harness. The ECU and DAQ interface with two built-in USART ports on the AT90CAN128 micro-controller. A MAX232 dual RS-232 trasceiver chip was used in the design to interface the built-in UARTS on the AT90CAN128 with the line levels expected by the serial ports on the ECU and DAQ.

\subsubsection{XBee-PRO Wireless Modem and External SPI UART}

To meet the range and data throughput requirements for the telemetry system, an XBee-PRO wireles modem was used. The XBee requires \unit{3.3}{\volt} I/O levels and power supply, and so a second linear voltage regulator was used in the design, the LT1521 from Linear Technology. Since the AT90CAN129 has only 2 built-in UARTS that were used for the RS232 interfaces to the ECU and DAQ, an third external UART was added to the design. The MAX3100 is a SPI-interfaced UART with an 8 word deep FIFO buffer. It is interfaced to the AT90CAN128's SPI pins and has an active-low IRQ line connected to external interrupt line EXT7 on the microcontroller.

The wireless transmitter consumes at most \unit{215}{\milli\ampere} of current during transmit \cite{XBeeManual}. Since the common module hardware only provides power for 5V devices, the telemetry module has a second LDO regulator providing \unit{3.3}{\volt}. A separate antenna port is connected to the modem and mounted in the side of the module enclosure.

Since the XBee, MAX3100, and AT90CAN128 are operating at different logic levels, a dual-supply level translator was used. Signals between the XBee, MAX3100, and the low supply voltage side of the level translator use \unit{+3.3}{\volt} logic, while signals between the AT90CAN128 and the high supply voltage side of the level translator use \unit{+5}{\volt} logic.

\subsection{Software}

The primary objective of the software running on the telemetry module is to push data around from various sources to various sinks. An overview of the telemetry module's system software can be seen in Fig.\ \ref{fig:telemetry_software_implementation}. A layer of software drivers interacts directly with the hardware, providing an easy-to-use interface for the specific system software to use. Interrupt-driven USART drivers were written for the on-board USARTs of the AT90CAN128, as well as the MAX3100 external UART.

Three major libraries 

Nearly 3000 lines of c code were written by us for the telemetry modules' system software. 3800 lines of code were also contributed by David Schilling for the DAC library.

\begin{figure}[H]
\centering
\input{implementation/figures/telemetry_software_block.tex}
\caption{Telemetry module software overview.}
\label{fig:telemetry_software_implementation}
\end{figure}

\subsubsection{MAX3100 External UART Driver}

The software driver written for the MAX3100 exteran UART was crafted in the image of the built-in USART driver, and shares the same software interfaces and buffering code. The drivers was written to utilize the external hardware interrupt to allow asynchronous sending and receiving of data. A statically allocated circular buffering approach was taken for both receiving and transmitting data. An abstracted flow chart of the interrupt handling is shown in Fig.\ \ref{fig:usart_driver_flow}.

The datahseet for the MAX3100 states that the minimum SPI Clock period is $t_{CP}=\unit{238}{\nano\second}$, which results in a maximum frequency of approximately $\unit{4.2}{\mega\hertz}$ \cite{MAX3100}. The SPI periferal was thus set to use 1/4 of the system clocks frequency when communicating with the MAX3100, resulting in $\unit{4}{\mega\hertz}$ SPI clock speed.

\begin{figure}[H]
\centering
\input{implementation/figures/usart_driver_flow.tex}
\caption{Basic USART interrupt flow diagram.}
\label{fig:usart_driver_flow}
\end{figure}

\subsubsection{XBee Library}

In order to facilitate routing data to and from multiple sources and sinks, it was determined that the XBee would need to be interfaced using the special ``API'' mode described in the XBee documentation \cite{XBeeManual}. The API mode is characterized by a packet interface that would require a supporting library in software. The library was written to implement two critical pieces of functionality:

\begin{enumerate}
\item and to send and receive packetized data from the modem on behalf of the user software as per the XBee's API specification \cite{XBeeManual};
\item to set the modem into API mode operation and manage the modem's operating state;
\end{enumerate}

The XBee library can be split logically into two chunks: code to packetize outgoing data for the main control loop software, and code to disassemble incoming packets and provide their payload to the main control loop.

The XBee library implements the binary packet protocol described in the XBee manual, and is able to send and receive unicast and multicast packets. The driver is only capable of sending packets to 16-bit addresses. Full 64-bit address mode was not implemented as the address space was not required in our 3 node network. The driver is also capable of sending command-type packets to the modem and reading the response.

When the mainline software wants to send a packet, it calls the \verb|xbee_send_data()| function. A pointer to the data as well as the 16-bit address is passed. The packet is constructed, and the packetized data is added to the MAX3100 driver's TX buffer to be sent to the XBee.

Receiving packets is more complicated, since individual bytes arrive at the MAX3100 drivers's RX buffer asynchronously. A state machine was constructed that waits for a full packet to be available in the RX buffer, and then pushes it into a seperate, incoming packet buffer. This incoming packet buffer can then be read by the mainline code.

Managing the modem's state was implemented as a state machine. Since minimal functionality was required, only a handful of modem commands were implemented. The driver is able to push the modem into API mode, after which all communication is done using the packet interface. The modem commands implemented by the telemetry module are listed in Table \ref{tab:xbee_commands}.

\begin{table}
\caption{Implemented XBee modem commands.\label{tab:xbee_commands}}
\centering{}
\begin{tabular}{|l|l|}
\hline 
Command & Description \tabularnewline
\hline
\hline
AP & Set and read the API mode state \tabularnewline
\hline
CH & Set and read the RF channel \tabularnewline
\hline 
ID & Set and read the PAN (Personal Area Network) ID \tabularnewline
\hline
MY & Set and read the modems local address \tabularnewline
\hline
\end{tabular}
\end{table}

The XBee modem can be controlled out of API mode by entering into it's command mode by sending a special string of bytes, by default ``+++''. A list of modem-style AT-commands, documented in the manual, are used to change the various settings of the modem. This command mode was used to initially set up the modems by hand, but is only used by the software once on startup to enable the API mode.

Similar to the rest of the software drivers implemented, the XBee library uses callbacks to provide the user software with incoming data. Function pointers are used to connect the library to a UART, which makes it possible to reconfigure the library to use a different USART on-the-fly.

\subsubsection{DAC Library\label{sec:dac_library}}

To reduce the implementation work required by us, we asked David Schilling, a computer science student on the Formula SAE team, to write the DAC software library to read and write the DAC's serial format, given the requirements described in Section \ref{sec:Telemetry-Module-Design}.

The DAC library maintains it's own buffer of incoming DAC data. We also asked Dave to provide seperate functions for buffering incoming data, and for processing that data. This seperation allowed the library to be easily tied in with the rest of the system software on the telemetry module: adding data to the DAC buffer occurs whenever the internal USART driver interrupts with a new byte, and processing is called from the mainline loop.

Transmission of DAC data over the wireless link is synchronized with the DAC Libraries' decoder. Whenever an entire DAC packet is decoded by the library, that packet is then sent in it's entirety over the link. Since transmission is done packet-wise, and not byte-by-byte, the injection of arbitrary packets into the DAC serial stream is possible without having packets collide.

\subsubsection{Main Control Loop}

Once all of the hardware on the module is initialized and the XBee has successfully entered API mode, the telemetry module's main control loop repeatedly calls the \verb|telemetry_process()| function. This function runs through three seperate processes:
\begin{enumerate}
  \item The RX buffer of the USART that the ECU is connected to is polled for data. If there is any incoming data waiting, send it over the ECU link by passing it to the packetizer;
  \item all decoded packets in the incoming packet buffer are dealt with, by calling\\ \verb|xbee_digest_incoming_packets()|;
  \item and finally, an iteration of the DAC libraries' decoder function is called,\\ \verb|dac_decode_serial()|. This checks to see if any of the buffered incoming DAC data can be decoded.
\end{enumerate}

Incoming DAC data does not need to be polled in the same way as with the ECU, since an incoming byte callback is set which places any incoming DAC bytes into the DAC libraries' own buffer.