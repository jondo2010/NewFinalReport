\section{Common Software Implementation\label{sec:common_software_implementation}}

Although not nearly as visible as the hardware aspects of the implementation, hidden beneath the surface is a substantial amount of system code written to implement the soft aspects of the design.

\subsection{Methodology}

The reusability of the system code written for all modules was a concern that had to be balanced with the need to write concise functionality. Being able to reuse portions of code written for one module in another was expected, however portability to other projects was not considered at all. Low level drivers for the CAN, UART, EEPROM and SPI periferals were all written as c libraries that could be reused and linked into module-specific code.

Due to the constraint on the available resources on the microcontroller, code efficiency was of the utmost concern. Especially in consideration of memory usage, the AT90CAN only has \unit{4}{\kilo\byte} ram, so wherever possible 8-bit data types were used. The size of buffers were also carefully managed. Due to known issues with the implementation of malloc(), the use dynamically allocated memory was avoided. Since a comparatively large amount of ROM is available on the AT90CAN128 (\unit{128}{\kilo\byte}Large statically allocated constant data was moved from positions in RAM to positions in the ROM

\subsection{Toolchain}

Programming and debugging software on the microcontroller was done through a standard IEEE 1149.1 JTAG interface. Atmel provides support for their own compiler, toolchain and IDE for Windows, however GNU support for the Atmel 8-bit microcontrollers is very good. Since all development of the system software was to be done on Unix-type operating systems, we decided to use the GNU toolchain \emph{gcc-avr} and \emph{binutils-avr}. Additionally \emph{GDB} was used with an AVR-JTAG gateway utility called \emph{avarice}. Using a hardware programmer/debugger device from Atmel connected to a USB port on the development PC, avarice communicates with the microcontroller using Atmel specific JTAG commands. GDB then connects to avarice, and allows the user to set brakepoints, control execution, and access memory on the microcontroller.

\nomenclature{JTAG}{Joint Test and Action Group}

\subsection{Common Low-Level Drivers}

\subsubsection{CAN Driver}

\subsubsection{EEPROM Driver}

\subsubsection{SPI Driver}
